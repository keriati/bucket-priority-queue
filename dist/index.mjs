var r=class{constructor(e=[]){this.buckets=[];this.pointer=0;this._size=0;this.contains=this.has;for(let t=0;t<e.length;t++)this.push(e[t][0],e[t][1])}add(e,t){this.push(e,t)}poll(){return this.pop()}peek(){if(!this._size)return;let e=this.buckets[this.pointer];return e[e.length-1]}clear(){this.buckets=[],this.pointer=0,this._size=0}refill(e){this.clear();for(let t=0;t<e.length;t++)this.push(e[t][0],e[t][1])}has(e){var t;for(let i=0;i<this.buckets.length;i++)if((t=this.buckets[i])!=null&&t.includes(e))return!0;return!1}toArray(){let e=[];for(let t=0;t<this.buckets.length;t++)e.push(...this.buckets[t]);return e}get size(){return this._size}};var h=class extends r{push(e,t){this.buckets[t]||(this.buckets[t]=[]),this.buckets[t].push(e),this._size===0?this.pointer=t:t>this.pointer&&(this.pointer=t),this._size++}pop(){var i;if(!this._size)return;let e=this.buckets[this.pointer],t=e.pop();if(e.length===0){for(let s=this.buckets.length-1;s>=0;s--)if(((i=this.buckets[s])==null?void 0:i.length)>0){this.pointer=s;break}}return this._size--,t}};var o=class extends r{push(e,t){this.buckets[t]||(this.buckets[t]=[]),this.buckets[t].push(e),this._size===0?this.pointer=t:t<this.pointer&&(this.pointer=t),this._size++}pop(){var i;if(!this._size)return;let e=this.buckets[this.pointer],t=e.pop();if(e.length===0){for(let s=0;s<this.buckets.length;s++)if(((i=this.buckets[s])==null?void 0:i.length)>0){this.pointer=s;break}}return this._size--,t}};export{h as MaxBucketQueue,o as MinBucketQueue};
//# sourceMappingURL=index.mjs.map